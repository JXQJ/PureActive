// ***********************************************************************
// Assembly         : PureActive.Core
// Author           : SteveBu
// Created          : 11-01-2018
// License          : Licensed under MIT License, see https://github.com/PureActive/PureActive/blob/master/LICENSE
//
// Last Modified By : SteveBu
// Last Modified On : 11-20-2018
// ***********************************************************************
// <copyright file="ByteUtility.cs" company="BushChang Corporation">
//     © 2018 BushChang Corporation. All rights reserved.
// </copyright>
// <summary></summary>
// ***********************************************************************
using System;
using System.Text;

namespace PureActive.Core.Utilities
{
    /// <summary>
    /// Class ByteUtility.
    /// </summary>
    /// <autogeneratedoc />
    public static class ByteUtility
    {
        /// <summary>
        /// The hexadecimal index
        /// </summary>
        /// <autogeneratedoc />
        private const string HexIndex = "0123456789abcdef          ABCDEF";
        /// <summary>
        /// The hexadecimal chars
        /// </summary>
        /// <autogeneratedoc />
        private const string HexChars = "0123456789ABCDEF";

        #region Public Members

        // byte
        /// <summary>
        /// Gets the bit.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="position">The position.</param>
        /// <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        /// <autogeneratedoc />
        public static bool GetBit(byte value, int position)
        {
            return GetBits(value, position, 1) == 1;
        }

        /// <summary>
        /// Sets the bit.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="position">The position.</param>
        /// <param name="flag">if set to <c>true</c> [flag].</param>
        /// <returns>System.Byte.</returns>
        /// <autogeneratedoc />
        public static byte SetBit(ref byte value, int position, bool flag)
        {
            return SetBits(ref value, position, 1, flag ? (byte) 1 : (byte) 0);
        }

        /// <summary>
        /// Gets the bits.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="position">The position.</param>
        /// <param name="length">The length.</param>
        /// <returns>System.Byte.</returns>
        /// <autogeneratedoc />
        public static byte GetBits(byte value, int position, int length)
        {
            if (length <= 0 || position >= 8)
                return 0;

            int mask = (2 << (length - 1)) - 1;

            return (byte) ((value >> position) & mask);
        }

        /// <summary>
        /// Sets the bits.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="position">The position.</param>
        /// <param name="length">The length.</param>
        /// <param name="bits">The bits.</param>
        /// <returns>System.Byte.</returns>
        /// <autogeneratedoc />
        public static byte SetBits(ref byte value, int position, int length, byte bits)
        {
            if (length <= 0 || position >= 8)
                return value;

            int mask = (2 << (length - 1)) - 1;

            value &= (byte) ~(mask << position);
            value |= (byte) ((bits & mask) << position);

            return value;
        }

        // ushort
        /// <summary>
        /// Gets the bit.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="position">The position.</param>
        /// <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        /// <autogeneratedoc />
        public static bool GetBit(ushort value, int position)
        {
            return GetBits(value, position, 1) == 1;
        }

        /// <summary>
        /// Sets the bit.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="position">The position.</param>
        /// <param name="flag">if set to <c>true</c> [flag].</param>
        /// <returns>System.UInt16.</returns>
        /// <autogeneratedoc />
        public static ushort SetBit(ref ushort value, int position, bool flag)
        {
            return SetBits(ref value, position, 1, flag ? (ushort) 1 : (ushort) 0);
        }

        /// <summary>
        /// Gets the bits.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="position">The position.</param>
        /// <param name="length">The length.</param>
        /// <returns>System.UInt16.</returns>
        /// <autogeneratedoc />
        public static ushort GetBits(ushort value, int position, int length)
        {
            if (length <= 0 || position >= 16)
                return 0;

            int mask = (2 << (length - 1)) - 1;

            return (ushort) ((value >> position) & mask);
        }

        /// <summary>
        /// Sets the bits.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="position">The position.</param>
        /// <param name="length">The length.</param>
        /// <param name="bits">The bits.</param>
        /// <returns>System.UInt16.</returns>
        /// <autogeneratedoc />
        public static ushort SetBits(ref ushort value, int position, int length, ushort bits)
        {
            if (length <= 0 || position >= 16)
                return value;

            int mask = (2 << (length - 1)) - 1;

            value &= (ushort) ~(mask << position);
            value |= (ushort) ((bits & mask) << position);

            return value;
        }

        // string
        /// <summary>
        /// Gets the safe string.
        /// </summary>
        /// <param name="bytes">The bytes.</param>
        /// <returns>System.String.</returns>
        /// <autogeneratedoc />
        public static string GetSafeString(byte[] bytes)
        {
            return bytes != null ? GetStringSkipNull(bytes, 0, bytes.Length) : "Null";
        }

        /// <summary>
        /// Gets the string null if empty.
        /// </summary>
        /// <param name="bytes">The bytes.</param>
        /// <returns>System.String.</returns>
        /// <autogeneratedoc />
        public static string GetStringNullIfEmpty(byte[] bytes)
        {
            if (bytes == null) return null;
            var s = GetStringSkipNull(bytes, 0, bytes.Length);

            return string.IsNullOrEmpty(s) ? null : s;
        }

        /// <summary>
        /// Gets the string.
        /// </summary>
        /// <param name="bytes">The bytes.</param>
        /// <returns>System.String.</returns>
        /// <autogeneratedoc />
        public static string GetString(byte[] bytes)
        {
            return bytes != null ? GetString(bytes, 0, bytes.Length) : string.Empty;
        }

        /// <summary>
        /// Gets the string.
        /// </summary>
        /// <param name="bytes">The bytes.</param>
        /// <param name="offset">The offset.</param>
        /// <param name="length">The length.</param>
        /// <returns>System.String.</returns>
        /// <autogeneratedoc />
        public static string GetString(byte[] bytes, int offset, int length)
        {
            StringBuilder sb = new StringBuilder();

            if (bytes != null)
            {
                for (int i = offset; i < length && i < bytes.Length; i++)
                    sb.Append((char) bytes[i]);
            }

            return sb.ToString();
        }


        /// <summary>
        /// Gets the string skip null.
        /// </summary>
        /// <param name="bytes">The bytes.</param>
        /// <param name="offset">The offset.</param>
        /// <param name="length">The length.</param>
        /// <returns>System.String.</returns>
        /// <autogeneratedoc />
        public static string GetStringSkipNull(byte[] bytes, int offset, int length)
        {
            StringBuilder sb = new StringBuilder();

            if (bytes != null)
            {
                for (int i = offset; i < length && i < bytes.Length; i++)
                {
                    if (bytes[i] != 0)
                        sb.Append((char) bytes[i]);
                }
            }

            return sb.ToString();
        }

        /// <summary>
        /// Prints the byte.
        /// </summary>
        /// <param name="b">The b.</param>
        /// <returns>System.String.</returns>
        /// <autogeneratedoc />
        public static string PrintByte(byte b)
        {
            return ByteToHex(b);
        }

        /// <summary>
        /// Byteses to hexadecimal.
        /// </summary>
        /// <param name="b">The b.</param>
        /// <returns>System.String.</returns>
        /// <autogeneratedoc />
        public static string BytesToHex(byte[] b)
        {
            StringBuilder sb = new StringBuilder();

            foreach (var ch in b)
                sb.Append(ByteToHex(ch));

            return sb.ToString();
        }

        /// <summary>
        /// Bytes to hexadecimal.
        /// </summary>
        /// <param name="b">The b.</param>
        /// <returns>System.String.</returns>
        /// <autogeneratedoc />
        public static string ByteToHex(byte b)
        {
            int lowByte = b & 0x0F;
            int highByte = (b & 0xF0) >> 4;

            return new string(
                new[] {HexChars[highByte], HexChars[lowByte]}
            );
        }

        /// <summary>
        /// Hexadecimals to byte.
        /// </summary>
        /// <param name="s">The s.</param>
        /// <returns>System.Byte[].</returns>
        /// <autogeneratedoc />
        public static byte[] HexToByte(string s)
        {
            int l = s.Length / 2;
            byte[] data = new byte[l];
            int j = 0;

            for (int i = 0; i < l; i++)
            {
                char c = s[j++];
                int n = HexIndex.IndexOf(c);
                int b = (n & 0xf) << 4;

                c = s[j++];
                n = HexIndex.IndexOf(c);
                b += n & 0xf;
                data[i] = (byte) b;
            }

            return data;
        }

        /// <summary>
        /// Prints the bytes.
        /// </summary>
        /// <param name="bytes">The bytes.</param>
        /// <returns>System.String.</returns>
        /// <autogeneratedoc />
        public static string PrintBytes(byte[] bytes)
        {
            return PrintBytes(bytes, bytes.Length);
        }

        /// <summary>
        /// Prints the safe bytes.
        /// </summary>
        /// <param name="bytes">The bytes.</param>
        /// <returns>System.String.</returns>
        /// <autogeneratedoc />
        public static string PrintSafeBytes(byte[] bytes)
        {
            if (bytes != null)
            {
                return PrintBytes(bytes, bytes.Length);
            }

            return "Null";
        }

        /// <summary>
        /// Prints the bytes.
        /// </summary>
        /// <param name="bytes">The bytes.</param>
        /// <param name="wrapLines">if set to <c>true</c> [wrap lines].</param>
        /// <returns>System.String.</returns>
        /// <autogeneratedoc />
        public static string PrintBytes(byte[] bytes, bool wrapLines)
        {
            return PrintBytes(bytes, bytes.Length, wrapLines);
        }

        /// <summary>
        /// Prints the bytes.
        /// </summary>
        /// <param name="bytes">The bytes.</param>
        /// <param name="length">The length.</param>
        /// <returns>System.String.</returns>
        /// <autogeneratedoc />
        public static string PrintBytes(byte[] bytes, int length)
        {
            return PrintBytes(bytes, length, true);
        }

        /// <summary>
        /// Prints the bytes.
        /// </summary>
        /// <param name="bytes">The bytes.</param>
        /// <param name="length">The length.</param>
        /// <param name="wrapLines">if set to <c>true</c> [wrap lines].</param>
        /// <returns>System.String.</returns>
        /// <autogeneratedoc />
        public static string PrintBytes(byte[] bytes, int length, bool wrapLines)
        {
            StringBuilder sb = new StringBuilder();

            int c = 0;

            for (int i = 0; i < length && i < bytes.Length; i++)
            {
                sb.Append(PrintByte(bytes[i]));

                if (++c == 24 && wrapLines)
                {
                    sb.Append(Environment.NewLine);
                    c = 0;
                }
                else if (i < length - 1)
                {
                    sb.Append("-");
                }
            }

            return sb.ToString();
        }

        /// <summary>
        /// Combines the specified value1.
        /// </summary>
        /// <param name="value1">The value1.</param>
        /// <param name="value2">The value2.</param>
        /// <returns>System.Byte[].</returns>
        /// <autogeneratedoc />
        public static byte[] Combine(byte[] value1, byte[] value2)
        {
            byte[] value = new byte[value1.Length + value2.Length];
            Array.Copy(value1, value, value1.Length);
            Array.Copy(value2, 0, value, value1.Length, value2.Length);

            return value;
        }

        /// <summary>
        /// Reverses the byte order.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>System.UInt16.</returns>
        /// <autogeneratedoc />
        public static ushort ReverseByteOrder(ushort value)
        {
            byte[] bytes = BitConverter.GetBytes(value);
            byte[] reverse = new byte[bytes.Length];

            var j = 0;
            for (var i = bytes.Length - 1; i >= 0; i--)
            {
                reverse[j++] = bytes[i];
            }

            return BitConverter.ToUInt16(reverse, 0);
        }

        /// <summary>
        /// Reverses the byte order.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>System.UInt32.</returns>
        /// <autogeneratedoc />
        public static uint ReverseByteOrder(uint value)
        {
            byte[] bytes = BitConverter.GetBytes(value);
            byte[] reverse = new byte[bytes.Length];

            var j = 0;
            for (var i = bytes.Length - 1; i >= 0; i--)
            {
                reverse[j++] = bytes[i];
            }

            return BitConverter.ToUInt32(reverse, 0);
        }

        /// <summary>
        /// Reverses the byte order.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>System.UInt64.</returns>
        /// <autogeneratedoc />
        public static ulong ReverseByteOrder(ulong value)
        {
            byte[] bytes = BitConverter.GetBytes(value);
            byte[] reverse = new byte[bytes.Length];

            var j = 0;
            for (var i = bytes.Length - 1; i >= 0; i--)
            {
                reverse[j++] = bytes[i];
            }

            return BitConverter.ToUInt64(reverse, 0);
        }

        /// <summary>
        /// Networks to system byte order.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>System.UInt16.</returns>
        /// <autogeneratedoc />
        public static ushort NetworkToSystemByteOrder(ushort value) =>
            BitConverter.IsLittleEndian ? ReverseByteOrder(value) : value;

        /// <summary>
        /// Networks to system byte order.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>System.UInt32.</returns>
        /// <autogeneratedoc />
        public static uint NetworkToSystemByteOrder(uint value) =>
            BitConverter.IsLittleEndian ? ReverseByteOrder(value) : value;

        /// <summary>
        /// Networks to system byte order.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>System.UInt64.</returns>
        /// <autogeneratedoc />
        public static ulong NetworkToSystemByteOrder(ulong value) =>
            BitConverter.IsLittleEndian ? ReverseByteOrder(value) : value;

        /// <summary>
        /// Reverses the byte order.
        /// </summary>
        /// <param name="bytes">The bytes.</param>
        /// <returns>System.Byte[].</returns>
        /// <autogeneratedoc />
        public static byte[] ReverseByteOrder(byte[] bytes)
        {
            byte[] reverse = new byte[bytes.Length];

            int j = 0;
            for (var i = bytes.Length - 1; i >= 0; i--)
            {
                reverse[j++] = bytes[i];
            }

            return reverse;
        }

        /// <summary>
        /// Bytes the search.
        /// </summary>
        /// <param name="searchIn">The search in.</param>
        /// <param name="searchBytes">The search bytes.</param>
        /// <param name="start">The start.</param>
        /// <returns>System.Int32.</returns>
        /// <autogeneratedoc />
        public static int ByteSearch(byte[] searchIn, byte[] searchBytes, int start = 0)
        {
            int found = -1;

            //only look at this if we have a populated search array and search bytes with a sensible start
            if (searchIn.Length > 0 && searchBytes.Length > 0 && start <= searchIn.Length - searchBytes.Length &&
                searchIn.Length >= searchBytes.Length)
            {
                //iterate through the array to be searched
                for (var i = start; i <= searchIn.Length - searchBytes.Length; i++)
                {
                    //if the start bytes match we will start comparing all other bytes
                    if (searchIn[i] == searchBytes[0])
                    {
                        if (searchIn.Length > 1)
                        {
                            //multiple bytes to be searched we have to compare byte by byte
                            var matched = true;
                            for (var y = 1; y <= searchBytes.Length - 1; y++)
                            {
                                if (searchIn[i + y] != searchBytes[y])
                                {
                                    matched = false;
                                    break;
                                }
                            }

                            //everything matched up
                            if (matched)
                            {
                                found = i;
                                break;
                            }
                        }
                        else
                        {
                            //search byte is only one bit nothing else to do
                            found = i;
                            break; //stop the loop
                        }
                    }
                }
            }

            return found;
        }

        /// <summary>
        /// Equalities the specified a1.
        /// </summary>
        /// <param name="a1">The a1.</param>
        /// <param name="b1">The b1.</param>
        /// <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        /// <autogeneratedoc />
        public static bool Equality(byte[] a1, byte[] b1)
        {
            // If not same length, done
            if (a1.Length != b1.Length)
            {
                return false;
            }

            // If they are the same object, done
            if (ReferenceEquals(a1, b1))
            {
                return true;
            }

            // Loop all values and compare
            for (var i = 0; i < a1.Length; i++)
            {
                if (a1[i] != b1[i])
                {
                    return false;
                }
            }

            // If we got here, equal
            return true;
        }

        #endregion Public Members
    }
}