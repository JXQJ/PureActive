// ***********************************************************************
// Assembly         : PureActive.Network.Services.NetworkMap
// Author           : SteveBu
// Created          : 11-05-2018
// License          : Licensed under MIT License, see https://github.com/PureActive/PureActive/blob/master/LICENSE
//
// Last Modified By : SteveBu
// Last Modified On : 11-20-2018
// ***********************************************************************
// <copyright file="NetworkMapService.cs" company="BushChang Corporation">
//     © 2018 BushChang Corporation. All rights reserved.
// </copyright>
// <summary></summary>
// ***********************************************************************
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Hosting;
using PureActive.Core.Extensions;
using PureActive.Hosting.Abstractions.Types;
using PureActive.Hosting.Hosting;
using PureActive.Network.Abstractions.CommonNetworkServices;
using PureActive.Network.Abstractions.DhcpService.Interfaces;
using PureActive.Network.Abstractions.Network;
using PureActive.Network.Abstractions.NetworkMapService;

namespace PureActive.Network.Services.NetworkMap
{
    /// <summary>
    /// Class NetworkMapService.
    /// Implements the <see cref="Hosting.Hosting.HostedServiceInternal{NetworkMapService}" />
    /// Implements the <see cref="INetworkMapService" />
    /// </summary>
    /// <seealso cref="Hosting.Hosting.HostedServiceInternal{NetworkMapService}" />
    /// <seealso cref="INetworkMapService" />
    /// <autogeneratedoc />
    public class NetworkMapService : HostedServiceInternal<NetworkMapService>, INetworkMapService
    {
        /// <summary>
        /// The network map service
        /// </summary>
        /// <autogeneratedoc />
        private static INetworkMapService _networkMapService;

        /// <summary>
        /// Initializes a new instance of the <see cref="NetworkMapService"/> class.
        /// </summary>
        /// <param name="networkMap">The network map.</param>
        /// <param name="dhcpService">The DHCP service.</param>
        /// <param name="applicationLifetime">The application lifetime.</param>
        /// <exception cref="ArgumentException">NetworkMapService Instance is not null - _networkMapService</exception>
        /// <exception cref="ArgumentNullException">
        /// networkMap
        /// or
        /// dhcpService
        /// </exception>
        /// <autogeneratedoc />
        public NetworkMapService(INetworkMap networkMap, IDhcpService dhcpService,
            IApplicationLifetime applicationLifetime = null) :
            base(networkMap?.CommonServices, applicationLifetime, ServiceHost.NetworkMap)
        {
            if (_networkMapService != null)
                throw new ArgumentException("NetworkMapService Instance is not null", nameof(_networkMapService));

            NetworkMap = networkMap ?? throw new ArgumentNullException(nameof(networkMap));
            DhcpService = dhcpService ?? throw new ArgumentNullException(nameof(dhcpService));

            _networkMapService = this;
        }

        /// <summary>
        /// Gets or sets the instance.
        /// </summary>
        /// <value>The instance.</value>
        /// <exception cref="ArgumentNullException">value</exception>
        /// <autogeneratedoc />
        private static INetworkMapService Instance
        {
            get => _networkMapService;
            set => _networkMapService = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Gets the DHCP service.
        /// </summary>
        /// <value>The DHCP service.</value>
        /// <autogeneratedoc />
        public IDhcpService DhcpService { get; }

        // Common Services
        /// <summary>
        /// Gets the network map.
        /// </summary>
        /// <value>The network map.</value>
        /// <autogeneratedoc />
        public INetworkMap NetworkMap { get; }

        /// <summary>
        /// Gets the common network services.
        /// </summary>
        /// <value>The common network services.</value>
        /// <autogeneratedoc />
        public ICommonNetworkServices CommonNetworkServices => NetworkMap?.CommonNetworkServices;

        /// <summary>
        /// Triggered when the application host is ready to start the service.
        /// </summary>
        /// <param name="cancellationToken">Indicates that the start process has been aborted.</param>
        /// <returns>Task.</returns>
        /// <autogeneratedoc />
        public override Task StartAsync(CancellationToken cancellationToken)
        {
            var tasks = new List<Task>
            {
                CommonNetworkServices.StartAsync(cancellationToken),
                DhcpService.StartAsync(cancellationToken),
                NetworkMap.StartAsync(cancellationToken)
            };

            var result = tasks.WaitForTasks(cancellationToken, Logger);

            base.StartAsync(cancellationToken);

            return result;
        }

        /// <summary>
        /// Triggered when the application host is performing a graceful shutdown.
        /// </summary>
        /// <param name="cancellationToken">Indicates that the shutdown process should no longer be graceful.</param>
        /// <returns>Task.</returns>
        /// <autogeneratedoc />
        public override Task StopAsync(CancellationToken cancellationToken)
        {
            var tasks = new List<Task>
            {
                NetworkMap.StopAsync(cancellationToken),
                CommonNetworkServices.StopAsync(cancellationToken),
                DhcpService.StopAsync(cancellationToken)
            };

            var result = tasks.WaitForTasks(cancellationToken, Logger);

            base.StopAsync(cancellationToken);

            return result;
        }

        /// <summary>
        /// Discovers the network devices.
        /// </summary>
        /// <returns>Task.</returns>
        /// <autogeneratedoc />
        public Task DiscoverNetworkDevices()
        {
            return Task.CompletedTask;
        }
    }
}