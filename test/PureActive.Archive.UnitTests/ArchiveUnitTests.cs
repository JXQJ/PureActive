// ***********************************************************************
// Assembly         : PureActive.Archive.UnitTests
// Author           : SteveBu
// Created          : 11-17-2018
// License          : Licensed under MIT License, see https://github.com/PureActive/PureActive/blob/master/LICENSE
//
// Last Modified By : SteveBu
// Last Modified On : 11-20-2018
// ***********************************************************************
// <copyright file="ArchiveUnitTests.cs" company="BushChang Corporation">
//     © 2018 BushChang Corporation. All rights reserved.
// </copyright>
// <summary></summary>
// ***********************************************************************

using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Text;
using FluentAssertions;
using Moq;
using PureActive.Archive.Abstractions.System;
using PureActive.Archive.Extensions;
using PureActive.Archive.System;
using PureActive.Core.Utilities;
using PureActive.Serilog.Sink.Xunit.TestBase;
using Xunit;
using Xunit.Abstractions;

namespace PureActive.Archive.UnitTests
{
    /// <summary>
    /// Class ArchiveUnitTests.
    /// Implements the <see cref="Serilog.Sink.Xunit.TestBase.TestBaseLoggable{ArchiveUnitTests}" />
    /// </summary>
    /// <seealso cref="Serilog.Sink.Xunit.TestBase.TestBaseLoggable{ArchiveUnitTests}" />
    [Trait("Category", "Unit")]
    public class ArchiveUnitTests : TestBaseLoggable<ArchiveUnitTests>
    {

        /// <summary>
        /// Initializes a new instance of the <see cref="ArchiveUnitTests" /> class.
        /// </summary>
        /// <param name="testOutputHelper">The test output helper.</param>
        /// <autogeneratedoc />
        public ArchiveUnitTests(ITestOutputHelper testOutputHelper) : base(testOutputHelper)
        {
            _archiveFactory = new ArchiveFactory();
        }

        private readonly IArchiveFactory _archiveFactory;

        private class RepositoryFile
        {
            /// <summary>
            /// The path to the file.
            /// </summary>
            public string Path { get; }

            /// <summary>
            /// The contents of the file.
            /// </summary>
            public string Contents => ByteUtility.GetString(_bytes);

            private readonly byte[] _bytes;

            /// <summary>
            /// Constructor.
            /// </summary>
            public RepositoryFile(string path, string contents)
            {
                Path = path;
                _bytes = Encoding.ASCII.GetBytes(contents);
            }

            /// <summary>
            /// Constructor.
            /// </summary>
            public RepositoryFile(string path, byte[] bytes)
            {
                Path = path;
                _bytes = bytes;
            }

            /// <summary>
            /// Returns the raw data of the file.
            /// </summary>
            public byte[] GetRawData()
            {
                return _bytes;
            }
        }


        /// <summary>
        /// Returns an archive with the given files.
        /// </summary>
        private IArchive GetArchive(params RepositoryFile[] files)
        {
            return new UncompressedMemoryArchive
            (
                files.ToDictionary
                (
                    file => file.Path,
                    file => file.GetRawData()
                )
            );
        }

        /// <summary>
        /// Defines the test method GetArchive.Files
        /// </summary>
        /// <autogeneratedoc />
        [Fact]
        public void Archive_GetArchive_Files()
        {
            var repositoryFiles = new[]
            {
                new RepositoryFile("Private/PrivateFile1.java", "ModifiedByStudent"),
                new RepositoryFile("Immutable/ImmutableFile1.java", "ModifiedByStudent"),
                new RepositoryFile("Public/PublicFile1.java", "ModifiedByStudent"),
                new RepositoryFile("Public/PublicFile2.txt", "ModifiedByStudent"),
                new RepositoryFile("Public/PublicFile2.bin",  new byte[]{0xFF, 0xFE})

            };

            
            int iFile = 0;
            using (var submissionContents = GetArchive(repositoryFiles))
            {
                submissionContents.Should().NotBeNull().And.Subject.Should().BeAssignableTo<IArchive>();

                foreach (var archiveFile in submissionContents.Files)
                {
                    archiveFile.FullPath.Should().Be(repositoryFiles[iFile].Path);
      
                    if (archiveFile.FullPath.EndsWith(".bin"))
                    {
                        archiveFile.Ascii.Should().BeFalse();
                        archiveFile.GetEncodedData().Should().Be(Convert.ToBase64String(archiveFile.GetRawData()));

                    }
                    else
                    {
                        ByteUtility.GetString(archiveFile.GetRawData()).Should().Be(repositoryFiles[iFile].Contents);
                        archiveFile.Ascii.Should().BeTrue();
                        archiveFile.GetEncodedData().Should().Be(repositoryFiles[iFile].Contents);
                    }
          


                    iFile++;
                }
            }

        }

        /// <summary>
        /// Returns the raw file data of a zip entry.
        /// </summary>
        private static byte[] GetRawFileData(ZipArchiveEntry entry)
        {
            using (var stream = entry.Open())
            using (var memoryStream = new MemoryStream())
            {
                stream.CopyTo(memoryStream);

                return memoryStream.ToArray();
            }
        }

        private IArchive GetMemoryBackedArchive(byte[] sourceRepoBytes)
        {
            using (var zipArchive = new ZipArchive(new MemoryStream(sourceRepoBytes)))
            {
                return _archiveFactory.CreateUncompressedArchive
                (
                    zipArchive.Entries
                        .Where(entry => entry.IsFile())
                        .ToDictionary
                        (
                            entry => entry.FullName.Substring
                            (
                                entry.FullName.IndexOf("/", StringComparison.Ordinal) + 1
                            ),
                            GetRawFileData
                        )
                );
            }
        }

        private IArchive GetMemoryBackedArchiveFromFile(string fileName)
        {
            using (FileStream zipToOpen = new FileStream(fileName, FileMode.Open))
            {
                var bytes = new byte[zipToOpen.Length];
                zipToOpen.Read(bytes);

                return GetMemoryBackedArchive(bytes);
            }
        }

        /// <summary>
        /// Defines the test method GetArchive.Files after calling Dispose
        /// </summary>
        /// <autogeneratedoc />
        [Fact]
        public void Archive_GetArchive_Files_Dispose()
        {
            var repositoryFiles = new[]
            {
                new RepositoryFile("Private/PrivateFile1.java", "ModifiedByStudent"),
                new RepositoryFile("Immutable/ImmutableFile1.java", "ModifiedByStudent"),
                new RepositoryFile("Public/PublicFile1.java", "ModifiedByStudent"),
                new RepositoryFile("Public/PublicFile2.txt", "ModifiedByStudent")
            };

            var submissionContents = GetArchive(repositoryFiles);
            submissionContents.Dispose();

            Func<IList<IArchiveFile>> fx = () => submissionContents.Files;

            fx.Should().Throw<ObjectDisposedException>().And.ObjectName.Should().Be("ZipFile");

        }

        [Fact]
        public void Archive_GetArchive_Uncompressed_FromZipFile()
        {
            var archive = GetMemoryBackedArchiveFromFile("Files\\KDTree.zip");
            archive.Should().NotBeNull();

            foreach (var archiveFile in archive.Files)
            {
                archiveFile.Should().NotBeNull();
                TestOutputHelper.WriteLine(archiveFile.FullPath);
            }

        }

        private IArchive CreateCompressedArchiveFromFile(string fileName, int stripInitialFolders)
        {
            using (FileStream zipToOpen = new FileStream(fileName, FileMode.Open))
            {
                var bytes = new byte[zipToOpen.Length];
                zipToOpen.Read(bytes);

                return _archiveFactory.CreateCompressedArchive(new ZipArchive(new MemoryStream(bytes), ZipArchiveMode.Read), stripInitialFolders);
            }
        }

        [Fact]
        public void Archive_GetArchive_Compressed_FromZipFile()
        {
            var archive = CreateCompressedArchiveFromFile("Files\\KDTree.zip", 1);
            archive.Should().NotBeNull();

            foreach (var archiveFile in archive.Files)
            {
                archiveFile.Should().NotBeNull();

                var archiveFileClass = archiveFile.As<CompressedArchiveFile>();
                archiveFileClass.Should().NotBeNull();

                archiveFileClass.GetRawData().Should().NotBeNull();

                TestOutputHelper.WriteLine(archiveFile.FullPath);
            }
        }

        [Fact]
        public void Archive_GetArchive_Compressed_FromZipFile_Dispose()
        {
            var archive = CreateCompressedArchiveFromFile("Files\\KDTree.zip", 1);
            archive.Should().NotBeNull();

            archive.Dispose();

            Func<IList<IArchiveFile>> fx = () => archive.Files;

            fx.Should().Throw<ObjectDisposedException>().And.ObjectName.Should().Be("ZipFile");
        }

    }
}