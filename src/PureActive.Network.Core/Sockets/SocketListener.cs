// ***********************************************************************
// Assembly         : PureActive.Network.Core
// Author           : SteveBu
// Created          : 11-05-2018
// License          : Licensed under MIT License, see https://github.com/PureActive/PureActive/blob/master/LICENSE
//
// Last Modified By : SteveBu
// Last Modified On : 11-20-2018
// ***********************************************************************
// <copyright file="SocketListener.cs" company="BushChang Corporation">
//     © 2018 BushChang Corporation. All rights reserved.
// </copyright>
// <summary></summary>
// ***********************************************************************
using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using Microsoft.Extensions.Logging;
using PureActive.Logging.Abstractions.Interfaces;

namespace PureActive.Network.Core.Sockets
{
    /// <summary>
    /// A class that listen for remote clients.
    /// Implements the <see cref="System.IDisposable" />
    /// </summary>
    /// <seealso cref="System.IDisposable" />
    public abstract class SocketListener : IDisposable
    {
        #region Private Properties

        /// <summary>
        /// The socket
        /// </summary>
        /// <autogeneratedoc />
        internal Socket Socket;
        /// <summary>
        /// The thread
        /// </summary>
        /// <autogeneratedoc />
        internal Thread Thread;

        /// <summary>
        /// The interface address
        /// </summary>
        /// <autogeneratedoc />
        private IPAddress _interfaceAddress = IPAddress.Any;
        /// <summary>
        /// The send buffer
        /// </summary>
        /// <autogeneratedoc />
        private readonly byte[] sendBuffer = new byte[1460];
        /// <summary>
        /// The receive timeout
        /// </summary>
        /// <autogeneratedoc />
        private int _receiveTimeout = -1;
        /// <summary>
        /// The send timeout
        /// </summary>
        /// <autogeneratedoc />
        private int _sendTimeout = -1;
        /// <summary>
        /// The listen backlog
        /// </summary>
        /// <autogeneratedoc />
        private int _listenBacklog = 10;
        /// <summary>
        /// The buffer size
        /// </summary>
        /// <autogeneratedoc />
        private int _bufferSize = 65535;
        /// <summary>
        /// The is active
        /// </summary>
        /// <autogeneratedoc />
        private bool _isActive;

        /// <summary>
        /// The logger.
        /// </summary>
        protected readonly IPureLogger Logger;

        #endregion Private Properties

        #region Public Properties

        /// <summary>
        /// Port that the server is listening on.
        /// </summary>
        /// <value>The active port.</value>
        /// <remarks>You can use port <c>0</c> to let the OS assign a port. This method will then give you the
        /// assigned port.</remarks>
        public int ActivePort
        {
            get
            {
                if (Socket == null)
                    return -1;

                return ((IPEndPoint) Socket.LocalEndPoint).Port;
            }
        }

        /// <summary>
        /// Gets or sets the ip address for receiving data
        /// </summary>
        /// <value>The interface address.</value>
        public IPAddress InterfaceAddress
        {
            get { return _interfaceAddress; }
            set { _interfaceAddress = value; }
        }

        /// <summary>
        /// Gets or sets the timeout for receiving data.
        /// </summary>
        /// <value>The receive timeout.</value>
        public int ReceiveTimeout
        {
            get { return _receiveTimeout; }
            set { _receiveTimeout = value; }
        }

        /// <summary>
        /// Gets or sets the timeout for sending data.
        /// </summary>
        /// <value>The send timeout.</value>
        public int SendTimeout
        {
            get { return _sendTimeout; }
            set { _sendTimeout = value; }
        }

        /// <summary>
        /// Gets or sets the socket listener backlog.
        /// </summary>
        /// <value>The listen backlog.</value>
        public int ListenBacklog
        {
            get { return _listenBacklog; }
            set { _listenBacklog = value; }
        }

        /// <summary>
        /// Gets or sets the socket listener buffer size.
        /// </summary>
        /// <value>The size of the buffer.</value>
        public int BufferSize
        {
            get { return _bufferSize; }
            set { _bufferSize = value; }
        }

        /// <summary>
        /// Gets or sets the socket listener active status.
        /// </summary>
        /// <value><c>true</c> if this instance is active; otherwise, <c>false</c>.</value>
        public bool IsActive
        {
            get { return _isActive; }
            set { _isActive = value; }
        }

        #endregion Public Properties

        #region Constructors / Deconstructors

        /// <summary>
        /// Initializes a new instance of the <see cref="SocketListener" /> class.
        /// </summary>
        /// <param name="logger">The logger.</param>
        public SocketListener(IPureLogger<SocketListener> logger)
        {
            Logger = logger;
        }

        /// <summary>
        /// Handles object cleanup for GC finalization.
        /// </summary>
        ~SocketListener()
        {
            Dispose(false);
        }

        /// <summary>
        /// Handles object cleanup.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Handles object cleanup
        /// </summary>
        /// <param name="disposing">True if called from Dispose(); false if called from GC finalization.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (IsActive)
                    Stop();
            }

            Thread = null;
        }

        #endregion  Constructors / Deconstructors

        #region Methods

        /// <summary>
        /// Stops the service listener if in started state.
        /// </summary>
        /// <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        /// <exception cref="InvalidOperationException">SocketListener is not active and must be started before stopping</exception>
        public bool Stop()
        {
            try
            {
                if (!IsActive)
                    throw new InvalidOperationException(
                        "SocketListener is not active and must be started before stopping");

                IsActive = false;

                Logger?.LogInformation("SocketListener stopped listening for requests on {LocalEndPoint}",
                    Socket.LocalEndPoint);

                return true;
            }
            catch (Exception ex)
            {
                Logger?.LogError(ex, "SocketLister stop failed");
            }

            return false;
        }

        /// <summary>
        /// Reads socket and processes packet
        /// </summary>
        /// <param name="socket">The active socket.</param>
        protected virtual void OnSocket(Socket socket)
        {
            try
            {
                if (socket.Poll(-1, SelectMode.SelectRead))
                {
                    var args = new ClientConnectedEventArgs(socket, Logger, _bufferSize);

                    EndPoint remoteEndPoint = new IPEndPoint(0, 0);

                    if (socket.Available == 0)
                        return;

                    args.ChannelBuffer.BytesTransferred = socket.ReceiveFrom(args.ChannelBuffer.Buffer,
                        SocketFlags.None, ref remoteEndPoint);
                    args.Channel.RemoteEndpoint = remoteEndPoint;

                    if (args.ChannelBuffer.BytesTransferred > 0)
                    {
                        OnClientConnected(args);

                        if (args.AllowConnect == false)
                        {
                            if (args.Response != null)
                            {
                                int sentBytes;
                                while ((sentBytes = args.Response.Read(sendBuffer, 0, sendBuffer.Length)) > 0)
                                {
                                    socket.Send(sendBuffer, sentBytes, SocketFlags.None);
                                }
                            }

                            Logger?.LogDebug(
                                "PACKET request on {LocalEndPoint} from {RemoteEndPoint} with channel id {ChannelId} was denied access to connect.",
                                socket.LocalEndPoint,
                                args.Channel.RemoteEndpoint,
                                args.Channel.ChannelId);
                        }
                    }
                }
                else
                {
                    Thread.Sleep(10);
                }
            }
            catch (SocketException ex)
            {
                if (ex.ErrorCode == (int) SocketError.ConnectionReset)
                {
                    Logger.LogError(ex, "SocketListener: socket connection reset");
                }
            }
            catch (Exception ex)
            {
                HandleDisconnect(SocketError.SocketError, ex);
            }
        }

        /// <summary>
        /// A client has connected (nothing have been sent or received yet)
        /// </summary>
        /// <param name="args">The <see cref="ClientConnectedEventArgs"/> instance containing the event data.</param>
        protected virtual void OnClientConnected(ClientConnectedEventArgs args)
        {
            ClientConnected(this, args);
        }

        /// <summary>
        /// A client has disconnected
        /// </summary>
        /// <param name="socket">Channel representing the client that disconnected</param>
        /// <param name="exception">Exception which was used to detect disconnect (<c>SocketException</c> with status
        /// <c>Success</c> is created for graceful disconnects)</param>
        protected virtual void OnClientDisconnected(Socket socket, Exception exception)
        {
            ClientDisconnected(this, new ClientDisconnectedEventArgs(socket, exception));
        }

        /// <summary>
        /// Detected a disconnect
        /// </summary>
        /// <param name="socketError">ProtocolNotSupported = decoder failure.</param>
        /// <param name="exception">Why socket got disconnected</param>
        protected void HandleDisconnect(SocketError socketError, Exception exception)
        {
            try
            {
                Socket.Close();
            }
            catch (Exception ex)
            {
                HandleDisconnect(SocketError.ConnectionReset, ex);
            }
        }

        #endregion Methods

        #region Events

        /// <summary>
        /// A client has connected (nothing have been sent or received yet)
        /// </summary>
        public event ClientConnectedEventHandler ClientConnected = delegate { };

        /// <summary>
        /// A client has connected (nothing have been sent or received yet)
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="args">The <see cref="ClientConnectedEventArgs"/> instance containing the event data.</param>
        public delegate void ClientConnectedEventHandler(object sender, ClientConnectedEventArgs args);

        /// <summary>
        /// A client has disconnected
        /// </summary>
        public event ClientDisconnectedEventHandler ClientDisconnected = delegate { };

        /// <summary>
        /// A client has disconnected
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="args">The <see cref="ClientDisconnectedEventArgs"/> instance containing the event data.</param>
        public delegate void ClientDisconnectedEventHandler(object sender, ClientDisconnectedEventArgs args);

        #endregion Events
    }
}