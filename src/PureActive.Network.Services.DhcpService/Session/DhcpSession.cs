// ***********************************************************************
// Assembly         : PureActive.Network.Services.DhcpService
// Author           : SteveBu
// Created          : 11-05-2018
// License          : Licensed under MIT License, see https://github.com/PureActive/PureActive/blob/master/LICENSE
//
// Last Modified By : SteveBu
// Last Modified On : 11-20-2018
// ***********************************************************************
// <copyright file="DhcpSession.cs" company="BushChang Corporation">
//     © 2018 BushChang Corporation. All rights reserved.
// </copyright>
// <summary></summary>
// ***********************************************************************
using System;
using System.Net.NetworkInformation;
using Microsoft.Extensions.Logging;
using PureActive.Core.Utilities;
using PureActive.Logging.Abstractions.Interfaces;
using PureActive.Network.Abstractions.DhcpService.Interfaces;
using PureActive.Network.Abstractions.DhcpService.Types;
using PureActive.Network.Abstractions.Types;

namespace PureActive.Network.Services.DhcpService.Session
{
    /// <summary>
    /// Class DhcpSession.
    /// Implements the <see cref="IDhcpSession" />
    /// </summary>
    /// <seealso cref="IDhcpSession" />
    /// <autogeneratedoc />
    public class DhcpSession : IDhcpSession
    {
        /// <summary>
        /// The default session time out
        /// </summary>
        /// <autogeneratedoc />
        private static readonly TimeSpan DefaultSessionTimeOut = new TimeSpan(0, 30, 0); // 30 minutes
        /// <summary>
        /// The DHCP service
        /// </summary>
        /// <autogeneratedoc />
        private readonly IDhcpService _dhcpService;

        /// <summary>
        /// The DHCP session result
        /// </summary>
        /// <autogeneratedoc />
        private readonly DhcpSessionResult _dhcpSessionResult;


        /// <summary>
        /// Initializes a new instance of the <see cref="DhcpSession"/> class.
        /// </summary>
        /// <param name="dhcpService">The DHCP service.</param>
        /// <param name="logger">The logger.</param>
        /// <param name="physicalAddress">The physical address.</param>
        /// <param name="sessionTimeOut">The session time out.</param>
        /// <exception cref="ArgumentNullException">dhcpService</exception>
        /// <autogeneratedoc />
        public DhcpSession(IDhcpService dhcpService, IPureLogger<DhcpSession> logger, PhysicalAddress physicalAddress,
            TimeSpan sessionTimeOut)
        {
            _dhcpService = dhcpService ?? throw new ArgumentNullException(nameof(dhcpService));
            PhysicalAddress = physicalAddress;
            _dhcpSessionResult = new DhcpSessionResult(physicalAddress);

            Logger = logger ?? throw new ArgumentNullException(nameof(logger));

            CreatedTimestamp = UpdatedTimestamp = DateTimeOffset.Now;
            SessionTimeOut = sessionTimeOut;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DhcpSession"/> class.
        /// </summary>
        /// <param name="dhcpService">The DHCP service.</param>
        /// <param name="logger">The logger.</param>
        /// <param name="physicalAddress">The physical address.</param>
        /// <autogeneratedoc />
        public DhcpSession(IDhcpService dhcpService, IPureLogger<DhcpSession> logger, PhysicalAddress physicalAddress) :
            this(dhcpService, logger, physicalAddress, DefaultSessionTimeOut)
        {
        }

        /// <summary>
        /// Gets the logger.
        /// </summary>
        /// <value>The logger.</value>
        /// <autogeneratedoc />
        public IPureLogger Logger { get; private set; }

        /// <summary>
        /// Gets the physical address.
        /// </summary>
        /// <value>The physical address.</value>
        /// <autogeneratedoc />
        public PhysicalAddress PhysicalAddress { get; }

        /// <summary>
        /// Gets the DHCP session result.
        /// </summary>
        /// <value>The DHCP session result.</value>
        /// <autogeneratedoc />
        public IDhcpSessionResult DhcpSessionResult => _dhcpSessionResult;

        /// <summary>
        /// Gets or sets the state of the request.
        /// </summary>
        /// <value>The state of the request.</value>
        /// <autogeneratedoc />
        public RequestState RequestState { get; set; } = RequestState.Unknown;

        /// <summary>
        /// Gets or sets the state of the DHCP session.
        /// </summary>
        /// <value>The state of the DHCP session.</value>
        /// <autogeneratedoc />
        public DhcpSessionState DhcpSessionState { get; set; } = DhcpSessionState.Init;

        /// <summary>
        /// Gets the DHCP discovered device.
        /// </summary>
        /// <value>The DHCP discovered device.</value>
        /// <autogeneratedoc />
        public IDhcpDiscoveredDevice DhcpDiscoveredDevice => DhcpSessionResult?.DhcpDiscoveredDevice;


        /// <summary>
        /// Gets the created timestamp.
        /// </summary>
        /// <value>The created timestamp.</value>
        /// <autogeneratedoc />
        public DateTimeOffset CreatedTimestamp { get; private set; }
        /// <summary>
        /// Gets or sets the updated timestamp.
        /// </summary>
        /// <value>The updated timestamp.</value>
        /// <autogeneratedoc />
        public DateTimeOffset UpdatedTimestamp { get; set; }

        /// <summary>
        /// Gets or sets the session time out.
        /// </summary>
        /// <value>The session time out.</value>
        /// <autogeneratedoc />
        public TimeSpan SessionTimeOut { get; set; }

        /// <summary>
        /// Updates the timestamp.
        /// </summary>
        /// <returns>DateTimeOffset.</returns>
        /// <autogeneratedoc />
        public DateTimeOffset UpdateTimestamp()
        {
            return UpdatedTimestamp = DateTimeOffset.Now;
        }


        /// <summary>
        /// Determines whether [has session expired] [the specified time stamp].
        /// </summary>
        /// <param name="timeStamp">The time stamp.</param>
        /// <param name="timeSpan">The time span.</param>
        /// <returns><c>true</c> if [has session expired] [the specified time stamp]; otherwise, <c>false</c>.</returns>
        /// <autogeneratedoc />
        public bool HasSessionExpired(DateTimeOffset timeStamp, TimeSpan timeSpan)
        {
            return timeStamp - UpdatedTimestamp > timeSpan;
        }

        /// <summary>
        /// Determines whether [has session expired].
        /// </summary>
        /// <returns><c>true</c> if [has session expired]; otherwise, <c>false</c>.</returns>
        /// <autogeneratedoc />
        public bool HasSessionExpired() => HasSessionExpired(DateTimeOffset.Now, DefaultSessionTimeOut);

        /// <summary>
        /// Processes the discover.
        /// </summary>
        /// <param name="dhcpMessage">The DHCP message.</param>
        /// <returns>DhcpMessageProcessed.</returns>
        /// <autogeneratedoc />
        public DhcpMessageProcessed ProcessDiscover(IDhcpMessage dhcpMessage)
        {
            _dhcpSessionResult.UpdateSessionState(dhcpMessage.SessionId, DhcpSessionState.Discover,
                dhcpMessage.ClientHardwareAddress);
            UpdateTimestamp();

            return DhcpMessageProcessed.Success;
        }

        /// <summary>
        /// Processes the request.
        /// </summary>
        /// <param name="dhcpMessage">The DHCP message.</param>
        /// <returns>DhcpMessageProcessed.</returns>
        /// <autogeneratedoc />
        public DhcpMessageProcessed ProcessRequest(IDhcpMessage dhcpMessage)
        {
            if (_dhcpSessionResult.IsDuplicateRequest(dhcpMessage))
            {
                return DhcpMessageProcessed.Duplicate;
            }


            // Update Session State
            _dhcpSessionResult.UpdateSessionState(dhcpMessage.SessionId, DhcpSessionState.Request,
                dhcpMessage.ClientHardwareAddress);

            var addressRequest = dhcpMessage.GetOptionData(DhcpOption.RequestedIpAddr);

            RequestState requestState;  // RequestState.Unknown

            #region Pre-Processing

            //  Start pre-process validation
            //---------------------------------------------------------------------
            //|              |INIT-REBOOT  |SELECTING    |RENEWING     |REBINDING |
            //---------------------------------------------------------------------
            //|broad/unicast |broadcast    |broadcast    |unicast      |broadcast |
            //|server-ip     |MUST NOT     |MUST         |MUST NOT     |MUST NOT  |
            //|requested-ip  |MUST         |MUST         |MUST NOT     |MUST NOT  |
            //|ciaddr        |zero         |zero         |IP address   |IP address|
            //---------------------------------------------------------------------
            // first determine what KIND of request we are dealing with
            if (dhcpMessage.ClientAddress.Equals(InternetAddress.Any))
            {
                // the ciAddr MUST be 0.0.0.0 for Init-Reboot and Selecting
                requestState = addressRequest == null ? RequestState.InitReboot : RequestState.Selecting;
            }
            else
            {
                // the ciAddr MUST NOT be 0.0.0.0 for Renew and Rebind
                if (!dhcpMessage.IsBroadcast)
                {
                    // renew is unicast
                    // NOTE: this will not happen if the v4 broadcast interface used at startup,
                    //		 but handling of DHCPv4 renew/rebind is the same anyway
                    requestState = RequestState.Renewing;
                }
                else
                {
                    // rebind is broadcast
                    requestState = RequestState.Rebinding;
                }
            }

            if (requestState == RequestState.InitReboot || requestState == RequestState.Selecting)
            {
                if (addressRequest == null)
                {
                    Logger.LogDebug(
                        "Ignoring {DhcpMessageType} {DhcpRequestState} message: Requested IP option is null",
                        MessageType.Request, RequestStateString.GetName(requestState));
                    //return; // if processing should not continue
                }
            }
            else
            {
                // type == Renewing or Rebinding
                if (addressRequest != null)
                {
                    Logger.LogDebug(
                        "Ignoring {DhcpMessageType} {DhcpRequestState} message: Requested IP option is not null",
                        MessageType.Request, RequestStateString.GetName(requestState));
                    //return; // if processing should not continue
                }
            }

            //  End pre-process validation

            #endregion Pre-Processing

            Logger.LogTrace("Processing {DhcpMessageType} {DhcpRequestState} message", MessageType.Request,
                RequestStateString.GetName(requestState));

            DhcpSessionState = DhcpSessionState.Request;
            RequestState = requestState;

            if (!dhcpMessage.ClientHardwareAddress.Equals(PhysicalAddress))
            {
                Logger.LogError(
                    "ClientHardwareAddress {ClientHardwareAddress} does not equal PhysicalAddress {PhysicalAddress}",
                    dhcpMessage.ClientHardwareAddress, PhysicalAddress);
            }

            // Update Hostname
            _dhcpSessionResult.HostName =
                ByteUtility.GetStringNullIfEmpty(dhcpMessage.GetOptionData(DhcpOption.Hostname));
            _dhcpSessionResult.VendorClassId =
                ByteUtility.GetStringNullIfEmpty(dhcpMessage.GetOptionData(DhcpOption.VendorClassId));

            bool routerDiscoveryParamExists = dhcpMessage.ParamOptionExists(DhcpOption.RouterDiscovery);

            // Figure out INetworkDeviceInfo

            if (routerDiscoveryParamExists)
            {

            }


            // TODO: Handle DhcpRequest
            UpdateTimestamp();

            return DhcpMessageProcessed.Success;
        }


        /// <summary>
        /// Processes the decline.
        /// </summary>
        /// <param name="dhcpMessage">The DHCP message.</param>
        /// <returns>DhcpMessageProcessed.</returns>
        /// <autogeneratedoc />
        public DhcpMessageProcessed ProcessDecline(IDhcpMessage dhcpMessage)
        {
            UpdateTimestamp();
            return DhcpMessageProcessed.Ignored;
        }


        /// <summary>
        /// Processes the release.
        /// </summary>
        /// <param name="dhcpMessage">The DHCP message.</param>
        /// <returns>DhcpMessageProcessed.</returns>
        /// <autogeneratedoc />
        public DhcpMessageProcessed ProcessRelease(IDhcpMessage dhcpMessage)
        {
            UpdateTimestamp();
            return DhcpMessageProcessed.Ignored;
        }


        /// <summary>
        /// Processes the inform.
        /// </summary>
        /// <param name="dhcpMessage">The DHCP message.</param>
        /// <returns>DhcpMessageProcessed.</returns>
        /// <autogeneratedoc />
        public DhcpMessageProcessed ProcessInform(IDhcpMessage dhcpMessage)
        {
            UpdateTimestamp();
            return DhcpMessageProcessed.Ignored;
        }

        /// <summary>
        /// Processes the ack.
        /// </summary>
        /// <param name="dhcpMessage">The DHCP message.</param>
        /// <returns>DhcpMessageProcessed.</returns>
        /// <autogeneratedoc />
        public DhcpMessageProcessed ProcessAck(IDhcpMessage dhcpMessage)
        {
            UpdateTimestamp();
            return DhcpMessageProcessed.Ignored;
        }
    }
}