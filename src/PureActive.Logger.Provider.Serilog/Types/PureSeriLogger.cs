// ***********************************************************************
// Assembly         : PureActive.Logger.Provider.Serilog
// Author           : SteveBu
// Created          : 10-23-2018
// License          : Licensed under MIT License, see https://github.com/PureActive/PureActive/blob/master/LICENSE
//
// Last Modified By : SteveBu
// Last Modified On : 11-20-2018
// ***********************************************************************
// <copyright file="PureSeriLogger.cs" company="BushChang Corporation">
//     © 2018 BushChang Corporation. All rights reserved.
// </copyright>
// <summary></summary>
// ***********************************************************************
using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Extensions.Logging;
using PureActive.Logging.Abstractions.Interfaces;
using Serilog.Context;
using Serilog.Core;
using Serilog.Core.Enrichers;
using ILoggerMsft = Microsoft.Extensions.Logging.ILogger;

namespace PureActive.Logger.Provider.Serilog.Types
{
    /// <summary>
    /// Class PureSeriLogger.
    /// Implements the <see cref="IPureLogger" />
    /// </summary>
    /// <seealso cref="IPureLogger" />
    /// <autogeneratedoc />
    public class PureSeriLogger : IPureLogger
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="PureSeriLogger"/> class.
        /// </summary>
        /// <param name="logger">The logger.</param>
        /// <exception cref="ArgumentNullException">logger</exception>
        /// <autogeneratedoc />
        public PureSeriLogger(ILoggerMsft logger)
        {
            WrappedLogger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Gets the wrapped logger.
        /// </summary>
        /// <value>The wrapped logger.</value>
        /// <autogeneratedoc />
        public ILoggerMsft WrappedLogger { get; }

        // Wrap ILogger interface methods
        /// <summary>
        /// Writes a log entry.
        /// </summary>
        /// <typeparam name="TState">The type of the t state.</typeparam>
        /// <param name="logLevel">Entry will be written on this level.</param>
        /// <param name="eventId">Id of the event.</param>
        /// <param name="state">The entry to be written. Can be also an object.</param>
        /// <param name="exception">The exception related to this entry.</param>
        /// <param name="formatter">Function to create a <c>string</c> message of the <paramref name="state" /> and <paramref name="exception" />.</param>
        /// <autogeneratedoc />
        public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception exception,
            Func<TState, Exception, string> formatter) =>
            WrappedLogger?.Log(logLevel, eventId, state, exception, formatter);

        /// <summary>
        /// Checks if the given <paramref name="logLevel" /> is enabled.
        /// </summary>
        /// <param name="logLevel">level to be checked.</param>
        /// <returns><c>true</c> if enabled.</returns>
        /// <autogeneratedoc />
        public bool IsEnabled(LogLevel logLevel) => WrappedLogger.IsEnabled(logLevel);

        /// <summary>
        /// Begins a logical operation scope.
        /// </summary>
        /// <typeparam name="TState">The type of the t state.</typeparam>
        /// <param name="state">The identifier for the scope.</param>
        /// <returns>An IDisposable that ends the logical operation scope on dispose.</returns>
        /// <autogeneratedoc />
        public IDisposable BeginScope<TState>(TState state) => WrappedLogger.BeginScope(state);

        /// <summary>
        /// Pushes the property.
        /// </summary>
        /// <param name="propertyName">Name of the property.</param>
        /// <param name="value">The value.</param>
        /// <param name="destructureObjects">if set to <c>true</c> [destructure objects].</param>
        /// <returns>IDisposable.</returns>
        /// <autogeneratedoc />
        public IDisposable PushProperty(string propertyName, object value, bool destructureObjects = false)
        {
            return LogContext.PushProperty(propertyName, value, destructureObjects);
        }

        /// <summary>
        /// Pushes the property.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="propertyName">Name of the property.</param>
        /// <param name="value">The value.</param>
        /// <param name="destructureObjects">if set to <c>true</c> [destructure objects].</param>
        /// <returns>IDisposable.</returns>
        /// <autogeneratedoc />
        public IDisposable PushProperty<T>(string propertyName, T value, bool destructureObjects = false)
        {
            return LogContext.PushProperty(propertyName, value, destructureObjects);
        }

        /// <summary>
        /// Pushes the log properties.
        /// </summary>
        /// <param name="properties">The properties.</param>
        /// <param name="destructureObjects">if set to <c>true</c> [destructure objects].</param>
        /// <returns>IDisposable.</returns>
        /// <exception cref="ArgumentNullException">properties</exception>
        /// <autogeneratedoc />
        public IDisposable PushLogProperties(IEnumerable<KeyValuePair<string, object>> properties,
            bool destructureObjects = false)
        {
            if (properties == null) throw new ArgumentNullException(nameof(properties));

            return LogContext.Push
            (
                properties.Select
                    (
                        p => new PropertyEnricher(p.Key, p.Value, destructureObjects)
                    ).Cast<ILogEventEnricher>()
                    .ToArray()
            );
        }

        /// <summary>
        /// Pushes the log properties.
        /// </summary>
        /// <param name="logPropertyList">The log property list.</param>
        /// <param name="minimumLogLevel">The minimum log level.</param>
        /// <returns>IDisposable.</returns>
        /// <exception cref="ArgumentNullException">logPropertyList</exception>
        /// <autogeneratedoc />
        public IDisposable PushLogProperties(IEnumerable<IPureLogPropertyLevel> logPropertyList,
            LogLevel minimumLogLevel)
        {
            if (logPropertyList == null) throw new ArgumentNullException(nameof(logPropertyList));

            var logPropertyListFiltered = logPropertyList
                .Where(p => p.MinimumLogLevel.CompareTo(minimumLogLevel) >= 0)
                .Select
                (
                    p => new PropertyEnricher(p.Key, p.Value, p.DestructureObject)
                )
                .Cast<ILogEventEnricher>()
                .ToArray();

            return LogContext.Push
            (
                logPropertyListFiltered
            );
        }

        /// <summary>
        /// Pushes the log properties.
        /// </summary>
        /// <param name="logPropertyList">The log property list.</param>
        /// <param name="includeLogProperty">The include log property.</param>
        /// <returns>IDisposable.</returns>
        /// <autogeneratedoc />
        public IDisposable PushLogProperties(IEnumerable<IPureLogPropertyLevel> logPropertyList,
            Func<IPureLogPropertyLevel, bool> includeLogProperty)
        {
            return LogContext.Push
            (
                logPropertyList
                    .Where(includeLogProperty)
                    .Select
                    (
                        p => new PropertyEnricher(p.Key, p.Value, p.DestructureObject)
                    )
                    .Cast<ILogEventEnricher>()
                    .ToArray()
            );
        }

        /// <summary>
        /// Pushes the log properties.
        /// </summary>
        /// <param name="logPropertyList">The log property list.</param>
        /// <returns>IDisposable.</returns>
        /// <exception cref="ArgumentNullException">logPropertyList</exception>
        /// <autogeneratedoc />
        public IDisposable PushLogProperties(IEnumerable<IPureLogProperty> logPropertyList)
        {
            if (logPropertyList == null) throw new ArgumentNullException(nameof(logPropertyList));

            return LogContext.Push
            (
                logPropertyList.Select
                    (
                        p => new PropertyEnricher(p.Key, p.Value, p.DestructureObject)
                    ).Cast<ILogEventEnricher>()
                    .ToArray()
            );
        }
    }

    /// <summary>
    /// Class PureSeriLogger.
    /// Implements the <see cref="PureSeriLogger" />
    /// Implements the <see cref="Logging.Abstractions.Interfaces.IPureLogger{T}" />
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <seealso cref="PureSeriLogger" />
    /// <seealso cref="Logging.Abstractions.Interfaces.IPureLogger{T}" />
    /// <autogeneratedoc />
    public class PureSeriLogger<T> : PureSeriLogger, IPureLogger<T>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="PureSeriLogger{T}"/> class.
        /// </summary>
        /// <param name="logger">The logger.</param>
        /// <autogeneratedoc />
        public PureSeriLogger(ILoggerMsft logger) : base(logger)
        {
        }
    }
}