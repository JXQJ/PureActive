// ***********************************************************************
// Assembly         : PureActive.Logging.Extensions
// Author           : SteveBu
// Created          : 11-05-2018
// License          : Licensed under MIT License, see https://github.com/PureActive/PureActive/blob/master/LICENSE
//
// Last Modified By : SteveBu
// Last Modified On : 11-20-2018
// ***********************************************************************
// <copyright file="PureLogPropertyLevel.cs" company="BushChang Corporation">
//     © 2018 BushChang Corporation. All rights reserved.
// </copyright>
// <summary></summary>
// ***********************************************************************
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Extensions.Logging;
using PureActive.Core.Extensions;
using PureActive.Logging.Abstractions.Interfaces;
using PureActive.Logging.Abstractions.Types;

namespace PureActive.Logging.Extensions.Types
{
    /// <summary>
    /// Class PureLogPropertyLevel.
    /// Implements the <see cref="PureActive.Logging.Extensions.Types.PureLogProperty" />
    /// Implements the <see cref="PureActive.Logging.Abstractions.Interfaces.IPureLogPropertyLevel" />
    /// </summary>
    /// <seealso cref="PureActive.Logging.Extensions.Types.PureLogProperty" />
    /// <seealso cref="PureActive.Logging.Abstractions.Interfaces.IPureLogPropertyLevel" />
    /// <autogeneratedoc />
    public class PureLogPropertyLevel : PureLogProperty, IPureLogPropertyLevel
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="PureLogPropertyLevel"/> class.
        /// </summary>
        /// <param name="keyValuePair">The key value pair.</param>
        /// <param name="minimumLogLevel">The minimum log level.</param>
        /// <param name="destructureObjects">if set to <c>true</c> [destructure objects].</param>
        /// <autogeneratedoc />
        public PureLogPropertyLevel(KeyValuePair<string, object> keyValuePair, LogLevel minimumLogLevel,
            bool destructureObjects = false) :
            base(keyValuePair, destructureObjects)
        {
            MinimumLogLevel = minimumLogLevel;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PureLogPropertyLevel"/> class.
        /// </summary>
        /// <param name="key">The key.</param>
        /// <param name="value">The value.</param>
        /// <param name="minimumLogLevel">The minimum log level.</param>
        /// <param name="destructureObjects">if set to <c>true</c> [destructure objects].</param>
        /// <autogeneratedoc />
        public PureLogPropertyLevel(string key, object value, LogLevel minimumLogLevel,
            bool destructureObjects = false) :
            this(new KeyValuePair<string, object>(key, value), minimumLogLevel, destructureObjects)
        {
        }

        /// <summary>
        /// Gets the minimum log level.
        /// </summary>
        /// <value>The minimum log level.</value>
        /// <autogeneratedoc />
        public LogLevel MinimumLogLevel { get; }

        /// <summary>
        /// Formats the property list.
        /// </summary>
        /// <param name="sb">The sb.</param>
        /// <param name="loggableFormat">The loggable format.</param>
        /// <param name="logPropertyEnumerable">The log property enumerable.</param>
        /// <param name="minimumLogLevel">The minimum log level.</param>
        /// <exception cref="ArgumentNullException">
        /// sb
        /// or
        /// logPropertyEnumerable
        /// </exception>
        /// <autogeneratedoc />
        public static void FormatPropertyList(StringBuilder sb, LoggableFormat loggableFormat,
            IEnumerable<IPureLogPropertyLevel> logPropertyEnumerable, LogLevel minimumLogLevel = LogLevel.Debug)
        {
            if (sb == null) throw new ArgumentNullException(nameof(sb));
            if (logPropertyEnumerable == null) throw new ArgumentNullException(nameof(logPropertyEnumerable));

            var logPropertyList = logPropertyEnumerable.ToList();
            var maxLength = logPropertyList.Select(p => p.Key).MaxStringLength() + 2;

            foreach (var logPropertyListItem in logPropertyList)
            {
                if (logPropertyListItem.MinimumLogLevel.CompareTo(minimumLogLevel) >= 0)
                {
                    sb.AppendLine(
                        $"{logPropertyListItem.Key.PadWithDelim(": ", maxLength)}{logPropertyListItem.Value}");
                }
            }
        }
    }
}