// ***********************************************************************
// Assembly         : PureActive.Network.Services.DhcpService
// Author           : SteveBu
// Created          : 11-05-2018
// License          : Licensed under MIT License, see https://github.com/PureActive/PureActive/blob/master/LICENSE
//
// Last Modified By : SteveBu
// Last Modified On : 11-20-2018
// ***********************************************************************
// <copyright file="DhcpMessage.cs" company="BushChang Corporation">
//     © 2018 BushChang Corporation. All rights reserved.
// </copyright>
// <summary></summary>
// ***********************************************************************
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.NetworkInformation;
using Microsoft.Extensions.Logging;
using PureActive.Core.Extensions;
using PureActive.Core.Utilities;
using PureActive.Logging.Abstractions.Interfaces;
using PureActive.Logging.Abstractions.Types;
using PureActive.Logging.Extensions.Types;
using PureActive.Network.Abstractions.DhcpService.Interfaces;
using PureActive.Network.Abstractions.DhcpService.Types;
using PureActive.Network.Abstractions.Extensions;
using PureActive.Network.Abstractions.Types;
using PureActive.Network.Extensions.IO;
using PureActive.Network.Services.DhcpService.Types;

namespace PureActive.Network.Services.DhcpService.Message
{
    #region RFC Specification

    /* Description:  Object that represents a DHCPv4 message as defined in
    *               RFC 2131.
    *               
    *  The following diagram illustrates the format of DHCP messages sent
    *  between server and clients:
    *
    *    0                   1                   2                   3
    *    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    *   |     op (1)    |   htype (1)   |   hlen (1)    |   hops (1)    |
    *   +---------------+---------------+---------------+---------------+
    *   |                            xid (4)                            |
    *   +-------------------------------+-------------------------------+
    *   |           secs (2)            |           flags (2)           |
    *   +-------------------------------+-------------------------------+
    *   |                          ciaddr  (4)                          |
    *   +---------------------------------------------------------------+
    *   |                          yiaddr  (4)                          |
    *   +---------------------------------------------------------------+
    *   |                          siaddr  (4)                          |
    *   +---------------------------------------------------------------+
    *   |                          giaddr  (4)                          |
    *   +---------------------------------------------------------------+
    *   |                                                               |
    *   |                          chaddr  (16)                         |
    *   |                                                               |
    *   |                                                               |
    *   +---------------------------------------------------------------+
    *   |                                                               |
    *   |                          sname   (64)                         |
    *   +---------------------------------------------------------------+
    *   |                                                               |
    *   |                          file    (128)                        |
    *   +---------------------------------------------------------------+
    *   |                                                               |
    *   |                          options (variable)                   |
    *   +---------------------------------------------------------------+
    */

    #endregion RFC Specification

    /// <summary>
    /// A class that represents a DHCP packet.
    /// See http://www.faqs.org/rfcs/rfc2131.html for full details of protocol.
    /// Implements the <see cref="Logging.Extensions.Types.PureLoggableBase{DhcpMessage}" />
    /// Implements the <see cref="IDhcpMessage" />
    /// </summary>
    /// <seealso cref="Logging.Extensions.Types.PureLoggableBase{DhcpMessage}" />
    /// <seealso cref="IDhcpMessage" />
    public class DhcpMessage : PureLoggableBase<DhcpMessage>, IDhcpMessage
    {
        #region Private Properties

        /// <summary>
        /// The random
        /// </summary>
        /// <autogeneratedoc />
        private static readonly Random Random = new Random();

        /// <summary>
        /// The op
        /// </summary>
        /// <autogeneratedoc />
        private byte _op;
        /// <summary>
        /// The htype
        /// </summary>
        /// <autogeneratedoc />
        private byte _htype;
        /// <summary>
        /// The hlen
        /// </summary>
        /// <autogeneratedoc />
        private byte _hlen;
        /// <summary>
        /// The hops
        /// </summary>
        /// <autogeneratedoc />
        private byte _hops;
        /// <summary>
        /// The xid
        /// </summary>
        /// <autogeneratedoc />
        private uint _xid;
        /// <summary>
        /// The secs
        /// </summary>
        /// <autogeneratedoc />
        private ushort _secs;
        /// <summary>
        /// The flags
        /// </summary>
        /// <autogeneratedoc />
        private byte[] _flags = new byte[2];
        /// <summary>
        /// The ciaddr
        /// </summary>
        /// <autogeneratedoc />
        private readonly byte[] _ciaddr = new byte[4];
        /// <summary>
        /// The yiaddr
        /// </summary>
        /// <autogeneratedoc />
        private readonly byte[] _yiaddr = new byte[4];
        /// <summary>
        /// The siaddr
        /// </summary>
        /// <autogeneratedoc />
        private readonly byte[] _siaddr = new byte[4];
        /// <summary>
        /// The giaddr
        /// </summary>
        /// <autogeneratedoc />
        private readonly byte[] _giaddr = new byte[4];
        /// <summary>
        /// The chaddr
        /// </summary>
        /// <autogeneratedoc />
        private readonly byte[] _chaddr = new byte[16];
        /// <summary>
        /// The sname
        /// </summary>
        /// <autogeneratedoc />
        private readonly byte[] _sname = new byte[64];
        /// <summary>
        /// The file
        /// </summary>
        /// <autogeneratedoc />
        private readonly byte[] _file = new byte[128];

        /// <summary>
        /// The options
        /// </summary>
        /// <autogeneratedoc />
        private readonly Dictionary<DhcpOption, byte[]> _options = new Dictionary<DhcpOption, byte[]>();
        /// <summary>
        /// The option ordering
        /// </summary>
        /// <autogeneratedoc />
        private byte[] _optionOrdering = { };
        /// <summary>
        /// The option data size
        /// </summary>
        /// <autogeneratedoc />
        private int _optionDataSize;

        #endregion Private Properties

        #region Constructors

        /// <summary>
        /// Initializes a new instance of the <see cref="DhcpMessage" /> class.
        /// </summary>
        /// <param name="loggerFactory">The logger factory.</param>
        /// <param name="logger">The logger.</param>
        public DhcpMessage(IPureLoggerFactory loggerFactory, IPureLogger logger = null) :
            base(loggerFactory, logger)
        {
            CreatedTimestamp = DateTimeOffset.Now;

            _op = (byte) OperationCode.BootReply;
            _htype = (byte) HardwareType.Ethernet;
            _hlen = 0;
            _hops = 0;
            _xid = (ushort) Random.Next(ushort.MaxValue);
            _secs = 0;
            Array.Clear(_flags, 0, _flags.Length);
            Array.Clear(_ciaddr, 0, _ciaddr.Length);
            Array.Clear(_yiaddr, 0, _yiaddr.Length);
            Array.Clear(_siaddr, 0, _siaddr.Length);
            Array.Clear(_giaddr, 0, _giaddr.Length);
            Array.Clear(_chaddr, 0, _chaddr.Length);
            Array.Clear(_sname, 0, _sname.Length);
            Array.Clear(_file, 0, _file.Length);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DhcpMessage" /> class.
        /// </summary>
        /// <param name="data">Array containing the data to decode.</param>
        /// <param name="loggerFactory">The logger factory.</param>
        /// <param name="logger">The logger.</param>
        public DhcpMessage(byte[] data, IPureLoggerFactory loggerFactory, IPureLogger logger = null)
            : base(loggerFactory, logger)
        {
            ByteReader byteReader = new ByteReader(data, ByteOrder.Network);

            CreatedTimestamp = DateTimeOffset.Now;

            _op = byteReader.ReadByte();
            _htype = byteReader.ReadByte();
            _hlen = byteReader.ReadByte();
            _hops = byteReader.ReadByte();
            _xid = byteReader.ReadUInt32();
            _secs = byteReader.ReadUInt16();
            _flags = byteReader.ReadBytes(2);
            _ciaddr = byteReader.ReadBytes(4);
            _yiaddr = byteReader.ReadBytes(4);
            _siaddr = byteReader.ReadBytes(4);
            _giaddr = byteReader.ReadBytes(4);
            _chaddr = byteReader.ReadBytes(16);
            _sname = byteReader.ReadBytes(64);
            _file = byteReader.ReadBytes(128);

            byte[] rawOptions = byteReader.ReadBytes(byteReader.AvailableBytes);
            int offset = 0;

            // if magic number is valid then process options
            if (offset + 4 < rawOptions.Length &&
                (BitConverter.ToUInt32(rawOptions, offset) == DhcpConstants.DhcpOptionsMagicNumber
                 || BitConverter.ToUInt32(rawOptions, offset) == DhcpConstants.DhcpWinOptionsMagicNumber))
            {
                offset += 4;
                bool end = false;

                while (!end && offset < rawOptions.Length)
                {
                    DhcpOption option = (DhcpOption) rawOptions[offset];
                    offset++;

                    int optionLen;

                    switch (option)
                    {
                        case DhcpOption.Pad:
                            continue;
                        case DhcpOption.End:
                            end = true;
                            continue;
                        default:
                            optionLen = rawOptions[offset];
                            offset++;
                            break;
                    }

                    byte[] optionData = new byte[optionLen];

                    Array.Copy(rawOptions, offset, optionData, 0, optionLen);
                    offset += optionLen;

                    _options.Add(option, optionData);
                    _optionDataSize += optionLen;
                }
            }
        }

        #endregion Constructors

        #region Public Properties

        /// <summary>
        /// The timestamp when cached.
        /// </summary>
        /// <value>The created timestamp.</value>
        public DateTimeOffset CreatedTimestamp { get; set; }

        /// <summary>
        /// The operation code of whatever last altered the packet (op).
        /// </summary>
        /// <value>The operation.</value>
        public OperationCode Operation
        {
            get { return (OperationCode) _op; }
            set { _op = (byte) value; }
        }

        /// <summary>
        /// The hardware address type (htype).
        /// </summary>
        /// <value>The hardware.</value>
        public HardwareType Hardware
        {
            get { return (HardwareType) _htype; }
            set { _htype = (byte) value; }
        }

        /// <summary>
        /// The hardware address length (hlen).
        /// </summary>
        /// <value>The length of the hardware address.</value>
        public byte HardwareAddressLength
        {
            get { return _hlen; }
            set { _hlen = value; }
        }

        /// <summary>
        /// Optionally used by relay agents when booting via a relay agent (hops).
        /// </summary>
        /// <value>The hops.</value>
        public byte Hops
        {
            get { return _hops; }
            set { _hops = value; }
        }

        /// <summary>
        /// A random number chosen by the client, to associate messages and responses between a client and a server (xid).
        /// </summary>
        /// <value>The session identifier.</value>
        public uint SessionId
        {
            get { return _xid; }
            set { _xid = value; }
        }

        /// <summary>
        /// The seconds elapsed since client began address acquisition or renewal process (secs).
        /// </summary>
        /// <value>The seconds elapsed.</value>
        public ushort SecondsElapsed
        {
            get { return _secs; }
            set { _secs = value; }
        }

        /// <summary>
        /// The leftmost bit is defined as the BROADCAST (B) flag.   The remaining bits of the flags field are reserved for
        /// future use.
        /// </summary>
        /// <value>The flags.</value>
        public byte[] Flags
        {
            get { return _flags; }
            set { _flags = value; }
        }

        /// <summary>
        /// Is Broadcast(true) / Unicast(false) flag
        /// </summary>
        /// <value><c>true</c> if this instance is broadcast; otherwise, <c>false</c>.</value>
        public bool IsBroadcast
        {
            get => ByteUtility.GetBits(_flags[0], 7, 1) == 1;
            set
            {
                if (value)
                {
                    _flags[0] = ByteUtility.SetBits(ref _flags[0], 15, 1, 1);
                }
                else
                {
                    _flags[0] = ByteUtility.SetBits(ref _flags[0], 15, 1, 0);
                }
            }
        }

        /// <summary>
        /// The client IP address (ciaddr).
        /// </summary>
        /// <value>The client address.</value>
        public InternetAddress ClientAddress
        {
            get { return new InternetAddress(_ciaddr); }
            set { CopyData(value.ToArray(), _ciaddr); }
        }

        /// <summary>
        /// The assigned client IP address (yiaddr).
        /// </summary>
        /// <value>The assigned address.</value>
        public InternetAddress AssignedAddress
        {
            get { return new InternetAddress(_yiaddr); }
            set { CopyData(value.ToArray(), _yiaddr); }
        }

        /// <summary>
        /// The server IP address (siaddr).
        /// </summary>
        /// <value>The next server address.</value>
        public InternetAddress NextServerAddress
        {
            get { return new InternetAddress(_siaddr); }
            set { CopyData(value.ToArray(), _siaddr); }
        }

        /// <summary>
        /// The gateway IP address (giaddr);
        /// </summary>
        /// <value>The relay agent address.</value>
        public InternetAddress RelayAgentAddress
        {
            get { return new InternetAddress(_giaddr); }
            set { CopyData(value.ToArray(), _giaddr); }
        }

        /// <summary>
        /// The client hardware address (chaddr).
        /// </summary>
        /// <value>The client hardware address.</value>
        public PhysicalAddress ClientHardwareAddress
        {
            get
            {
                byte[] hardwareAddress = new byte[_hlen];
                Array.Copy(_chaddr, hardwareAddress, _hlen);
                return new PhysicalAddress(hardwareAddress);
            }

            set
            {
                CopyData(value.ToArray(), _chaddr);
                _hlen = (byte) value.ToArray().Length;

                for (int i = value.ToArray().Length; i < 16; i++)
                {
                    _chaddr[i] = 0;
                }
            }
        }

        /// <summary>
        /// The DNS hostname part that corresponds with the given IP address (sname).
        /// </summary>
        /// <value>The name of the server.</value>
        public byte[] ServerName
        {
            get { return _sname; }
            set { CopyData(value, _sname); }
        }

        /// <summary>
        /// The boot file name the clients may use (file).
        /// </summary>
        /// <value>The name of the boot file.</value>
        public byte[] BootFileName
        {
            get { return _file; }
            set { CopyData(value, BootFileName); }
        }

        /// <summary>
        /// The option ordering parameter list.
        /// </summary>
        /// <value>The option ordering.</value>
        public byte[] OptionOrdering
        {
            get { return _optionOrdering; }
            set { _optionOrdering = value; }
        }

        #endregion Public Properties

        #region Methods

        /// <summary>
        /// Get option data.
        /// </summary>
        /// <param name="option">The option.</param>
        /// <returns>System.Byte[].</returns>
        public byte[] GetOptionData(DhcpOption option)
        {
            if (_options.ContainsKey(option))
            {
                return _options[option];
            }

            return null;
        }

        /// <summary>
        /// Remove all options.
        /// </summary>
        /// <autogeneratedoc />
        public void ClearOptions()
        {
            _optionDataSize = 0;
            _options.Clear();
        }

        /// <summary>
        /// Add or define a new custom option type.
        /// </summary>
        /// <param name="option">The option.</param>
        /// <param name="data">The data.</param>
        /// <exception cref="ArgumentException">The Pad and End DhcpOptions cannot be added explicitly - option</exception>
        public void AddOption(DhcpOption option, params byte[] data)
        {
            if (option == DhcpOption.Pad || option == DhcpOption.End)
            {
                throw new ArgumentException("The Pad and End DhcpOptions cannot be added explicitly", "option");
            }

            _options.Add(option, data);
            _optionDataSize += data.Length;
        }

        /// <summary>
        /// Parameters the option exists.
        /// </summary>
        /// <param name="paramOption">The parameter option.</param>
        /// <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        /// <autogeneratedoc />
        public bool ParamOptionExists(DhcpOption paramOption)
        {
            var paramOptions = GetOptionData(DhcpOption.ParamReqList);

            if (paramOptions == null) return false;

            foreach (var paramOptionItem in paramOptions)
            {
                if (paramOptionItem == (byte) paramOption)
                    return true;
            }

            return false;
        }

        /// <summary>
        /// Remove a custom option type.
        /// </summary>
        /// <param name="option">The option.</param>
        /// <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        public bool RemoveOption(DhcpOption option)
        {
            if (_options.ContainsKey(option))
            {
                byte[] optionValue = _options[option];
                _optionDataSize -= optionValue.Length;
                _options.Remove(option);
                return true;
            }

            return false;
        }

        /// <summary>
        /// DHCPs the option keys.
        /// </summary>
        /// <returns>IEnumerable&lt;DhcpOption&gt;.</returns>
        /// <autogeneratedoc />
        public IEnumerable<DhcpOption> DhcpOptionKeys() => _options.Keys;
        /// <summary>
        /// DHCPs the option values.
        /// </summary>
        /// <returns>IEnumerable&lt;System.Byte[]&gt;.</returns>
        /// <autogeneratedoc />
        public IEnumerable<byte[]> DhcpOptionValues() => _options.Values;

        /// <summary>
        /// Converts dhcp message into a byte array.
        /// </summary>
        /// <returns>System.Byte[].</returns>
        public byte[] ToArray()
        {
            ByteWriter byteWriter = new ByteWriter(DhcpConstants.DhcpMinMessageSize, ByteOrder.Network);

            byteWriter.Write(_op);
            byteWriter.Write(_htype);
            byteWriter.Write(_hlen);
            byteWriter.Write(_hops);
            byteWriter.Write(_xid);
            byteWriter.Write(_secs); // (ReverseByteOrder(BitConverter.GetBytes(this._secs))) ??
            byteWriter.Write(_flags);
            byteWriter.Write(_ciaddr);
            byteWriter.Write(_yiaddr);
            byteWriter.Write(_siaddr);
            byteWriter.Write(_giaddr);
            byteWriter.Write(_chaddr);
            byteWriter.Write(_sname);
            byteWriter.Write(_file);

            byte[] data = new byte[_options.Count > 0 ? 4 + _options.Count * 2 + _optionDataSize + 1 : 0];

            int offset = 0;
            if (_options.Count > 0)
            {
                BitConverter.GetBytes(DhcpConstants.DhcpWinOptionsMagicNumber).CopyTo(data, offset);
                offset += 4;

                foreach (byte optionId in _optionOrdering)
                {
                    DhcpOption option = (DhcpOption) optionId;
                    if (_options.ContainsKey(option))
                    {
                        data[offset++] = optionId;
                        byte[] optionValue = _options[option];

                        if (_options[option] != null && optionValue.Length > 0)
                        {
                            data[offset++] = (byte) optionValue.Length;
                            Array.Copy(_options[option], 0, data, offset, optionValue.Length);
                            offset += optionValue.Length;
                        }
                    }
                }

                foreach (DhcpOption option in _options.Keys)
                {
                    if (Array.IndexOf(_optionOrdering, (byte) option) == -1)
                    {
                        data[offset++] = (byte) option;
                        byte[] optionValue = _options[option];

                        if (_options[option] != null && optionValue.Length > 0)
                        {
                            data[offset++] = (byte) optionValue.Length;
                            Array.Copy(_options[option], 0, data, offset, optionValue.Length);
                            offset += optionValue.Length;
                        }
                    }
                }

                data[offset] = (byte) DhcpOption.End;
            }

            byteWriter.Write(data);

            return byteWriter.GetBytes();
        }

        /// <summary>
        /// Gets the DHCP option string.
        /// </summary>
        /// <param name="dhcpOption">The DHCP option.</param>
        /// <param name="dhcpRequestListFormat">The DHCP request list format.</param>
        /// <returns>System.String.</returns>
        /// <autogeneratedoc />
        private string GetDhcpOptionString(DhcpOption dhcpOption,
            DhcpOptionTypeMap.DhcpRequestListFormat dhcpRequestListFormat =
                DhcpOptionTypeMap.DhcpRequestListFormat.StringNewlineIndentedSeparated)
        {
            return DhcpOptionTypeMap.GetDhcpOptionString(dhcpOption, GetOptionData(dhcpOption), dhcpRequestListFormat,
                Logger);
        }

        /// <summary>
        /// Gets the log property list level.
        /// </summary>
        /// <param name="logLevel">The log level.</param>
        /// <param name="loggableFormat">The loggable format.</param>
        /// <returns>IEnumerable&lt;IPureLogPropertyLevel&gt;.</returns>
        /// <autogeneratedoc />
        public override IEnumerable<IPureLogPropertyLevel> GetLogPropertyListLevel(LogLevel logLevel,
            LoggableFormat loggableFormat)
        {
            var logPropertyLevels = loggableFormat.IsWithParents()
                ? base.GetLogPropertyListLevel(logLevel, loggableFormat)?.ToList()
                : new List<IPureLogPropertyLevel>();

            if (logLevel <= LogLevel.Information)
            {
                logPropertyLevels?.Add(new PureLogPropertyLevel("MessageTimeStamp", CreatedTimestamp.ToLocalTime(),
                    LogLevel.Information));
                logPropertyLevels?.Add(new PureLogPropertyLevel("MessageOp", OperationString.GetName(Operation),
                    LogLevel.Information));
                logPropertyLevels?.Add(new PureLogPropertyLevel("HardwareType)", HardwareString.GetName(Hardware),
                    LogLevel.Trace));
                logPropertyLevels?.Add(new PureLogPropertyLevel("Hops", ByteUtility.PrintByte(Hops), LogLevel.Trace));
                logPropertyLevels?.Add(new PureLogPropertyLevel("TrxId", SessionId.ToHexString("0x"),
                    LogLevel.Information));
                logPropertyLevels?.Add(new PureLogPropertyLevel("SecondsElapsed", SecondsElapsed.ToString(),
                    LogLevel.Trace));
                logPropertyLevels?.Add(
                    new PureLogPropertyLevel("Flags", ByteUtility.PrintBytes(_flags), LogLevel.Trace));
                logPropertyLevels?.Add(new PureLogPropertyLevel("IsBroadcast", IsBroadcast.ToString(), LogLevel.Trace));
                logPropertyLevels?.Add(new PureLogPropertyLevel("ClientAddress", ClientAddress.ToString(),
                    LogLevel.Debug));
                logPropertyLevels?.Add(new PureLogPropertyLevel("AssignedAddress", AssignedAddress.ToString(),
                    LogLevel.Debug));
                logPropertyLevels?.Add(new PureLogPropertyLevel("NextServerAddress", NextServerAddress.ToString(),
                    LogLevel.Trace));
                logPropertyLevels?.Add(new PureLogPropertyLevel("RelayAgentAddress", RelayAgentAddress.ToString(),
                    LogLevel.Trace));
                logPropertyLevels?.Add(new PureLogPropertyLevel("HardwareAddress", ClientHardwareAddress.ToString(),
                    LogLevel.Information));
                logPropertyLevels?.Add(new PureLogPropertyLevel("ServerName", ByteUtility.GetSafeString(ServerName),
                    LogLevel.Trace));
                logPropertyLevels?.Add(new PureLogPropertyLevel("BootFileName", ByteUtility.GetSafeString(BootFileName),
                    LogLevel.Trace));

                logPropertyLevels?.Add(new PureLogPropertyLevel("OptMessageType",
                    GetDhcpOptionString(DhcpOption.MessageType), LogLevel.Information));
                logPropertyLevels?.Add(new PureLogPropertyLevel("OptClientId", GetDhcpOptionString(DhcpOption.ClientId),
                    LogLevel.Trace));
                logPropertyLevels?.Add(new PureLogPropertyLevel("OptVendorClassId",
                    GetDhcpOptionString(DhcpOption.VendorClassId), LogLevel.Trace));
                logPropertyLevels?.Add(new PureLogPropertyLevel("OptHostName", GetDhcpOptionString(DhcpOption.Hostname),
                    LogLevel.Information));
                logPropertyLevels?.Add(new PureLogPropertyLevel("OptAddressRequest",
                    GetDhcpOptionString(DhcpOption.RequestedIpAddr), LogLevel.Information));
                logPropertyLevels?.Add(new PureLogPropertyLevel("OptServerIdentifier",
                    GetDhcpOptionString(DhcpOption.ServerId), LogLevel.Trace));
                logPropertyLevels?.Add(new PureLogPropertyLevel("OptParamReqList",
                    GetDhcpOptionString(DhcpOption.ParamReqList), LogLevel.Trace));
            }

            return logPropertyLevels?.Where(p => p.MinimumLogLevel.CompareTo(logLevel) >= 0);
        }

        /// <summary>
        /// Copy byte array object.
        /// </summary>
        /// <param name="source">The source.</param>
        /// <param name="dest">The dest.</param>
        /// <exception cref="ArgumentException">Values must be no more than " + dest.Length + " bytes.</exception>
        private void CopyData(byte[] source, byte[] dest)
        {
            if (source.Length > dest.Length)
            {
                throw new ArgumentException("Values must be no more than " + dest.Length + " bytes.");
            }

            source.CopyTo(dest, 0);
        }

        #endregion Methods
    }
}